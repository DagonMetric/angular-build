import * as path from 'path';
import * as resolve from 'resolve';
import * as semver from 'semver';
import * as yargs from 'yargs';

//import * as fs from 'fs-extra';
// ReSharper disable once CommonJsExternalModule
const fs = require('fs-extra');

import { CliOptions } from './models';
import { AngularBuildConfig, AppConfig } from '../models';
import { IconPluginOptions } from '../plugins/icon-webpack-plugin';

import {
    readJsonAsync, chageDashCase, mapToYargsType, checkFileOrDirectoryExistsAsync, findFileOrDirectoryFromPossibleAsync,
    getVersionfromPackageJsonAsync, spawnAsync
} from './utils';

import { Logger, colorize, validateSchema } from '../utils';

// ReSharper disable CommonJsExternalModule
const schema = require('../../configs/schema.json');
const faviconSchema = require('../../configs/favicon-config-schema.json');
// ReSharper restore CommonJsExternalModule

export interface PackageToCheck {
    packageName: string;
    isPreReleased?: boolean;
    version?: string;
    resolvedPath?: string;
};

export interface PackageJsonConfig {
    dependencies?: { [key: string]: string },
    devDependencies?: { [key: string]: string }
}

export interface CommandOptions {
    /**
     * Overrides angular-build.json file.
     */
    overrideAngularBuildConfigFile?: boolean;
    /**
     * Include test configs.
   * @default false
     */
    includeTestConfigs?: boolean;
    /**
     * Installs angular and other dependencies.
     */
    installPackages?: boolean;
    /**
    * Package manager to use while installing dependencies.
    * @default npm
    */
    packageManager?: 'npm' | 'yarn';
    /**
   * Link angular-build cli to current project.
   * @default false
   */
    link?: boolean;
}

export interface InitConfig {
    logger: Logger;
    cwd: string;
    cliIsLocal?: boolean;

    commandOptions?: CommandOptions & AppConfig;
    cliPackageJsonConfig?: PackageJsonConfig;

    angularBuildConfigMaster?: AngularBuildConfig;
    userAngularBuildConfig?: any;
    angularBuildConfigFileExists?: boolean;

    userAngularCliConfig?: any;
    angularCliConfigFileExists?: boolean;

    faviconConfigMaster?: IconPluginOptions;

    userPackageConfigFileExists?: boolean;
    userPackageConfigFile?: string;
    userPackageConfig?: any;

    tsConfigMaster?: any;
    tsConfigBrowserMaster?: any;
    tsConfigServerMaster?: any;
    tsConfigServerAoTMaster?: any;
    tsConfigTestMaster?: any;

    faviconConfigFileExists?: boolean;
    userFaviconConfig?: any;

    isAspNetCore?: boolean;
}

export function getInitCommandModule(cliVersion: string): yargs.CommandModule {
    const initCommandUsage = `\n${colorize(`angular-build ${cliVersion}`, 'green')}\n
Usage:
  ngb init [options...]`;


    const initCommandModule: yargs.CommandModule = {
        command: 'init',
        describe: 'Create angular-build config files',
        builder: (yargv: yargs.Argv) => {
            let yargvObj = yargv
                .reset()
                .usage(initCommandUsage)
                .example('ngb init --package-manager=yarn',
                'Create angular-build config files with yarn package manager option')
                .help('h')
                //.option('p',
                //    {
                //        alias: 'prompt',
                //        describe: 'Confirm user by prompting',
                //        type: 'boolean',
                //        default: false
                //    })
                //.option('install-deps',
                //{
                //    describe: 'Install required dependencies',
                //    type: 'boolean',
                //    default: false
                //})
                //.option('install-loaders-only',
                //{
                //    describe: 'Install loaders only',
                //    type: 'boolean',
                //    default: true
                //})
                .option('override-angular-build-config-file',
                {
                    describe: 'Override angular-build.json file',
                    type: 'boolean',
                    default: undefined
                })
                .option('include-test-configs',
                {
                    describe: 'Include test configs',
                    type: 'boolean',
                    default: false
                })
                .option('install-packages',
                {
                    describe: 'Install angular and other dependencies',
                    type: 'boolean',
                    default: true
                })
                .option('package-manager',
                {
                    describe: 'Package manager to use while installing dependencies',
                    type: 'string'
                })
                .option('l',
                {
                    alias: 'link',
                    describe: 'Link angular-build cli to current project',
                    type: 'boolean',
                    default: false
                });

            const appConfigSchema: any = schema.definitions.AppConfig.properties;
            Object.keys(appConfigSchema).filter((key: string) => key !== 'extends').forEach((key: string) => {
                yargvObj = yargvObj.options(chageDashCase(key),
                    {
                        describe: appConfigSchema[key].description || key,
                        type: mapToYargsType(appConfigSchema[key].type),
                        default: undefined
                    });
            });

            return yargvObj;
        },
        handler: null
    };

    return initCommandModule;
}

// Command
//
export function init(cliOptions: CliOptions): Promise<number> {
    const projectRoot = cliOptions.cwd || process.cwd();
    const logger = cliOptions.logger;

    logger.logLine(`\n${colorize(`angular-build ${cliOptions.cliVersion}`, 'green')}`);

    const cfg: InitConfig = {
        logger: logger,
        cwd: projectRoot,
        cliIsLocal: cliOptions.cliIsLocal,
        commandOptions: Object.assign({}, cliOptions.commandOptions || {})
    };

    let actionCount = 0;

    return checkFileOrDirectoryExistsAsync(path.resolve(projectRoot, 'package.json'))
        .then((exists: boolean) => {
            if (exists) {
                cfg.userPackageConfigFileExists = true;
                cfg.userPackageConfigFile = path.resolve(projectRoot, 'package.json');
                return Promise.resolve();
            } else {
                logger.log('\n');
                const msg =
                    `'package.json' file doesn't exist. Please run ${colorize('npm init', 'cyan')} or ${
                    colorize('yarn init', 'cyan')} command to init 'package.json' file.`;
                logger.errorLine(msg);
                return Promise.reject(null);
            }
        })
        // Read master files
        .then(() => {
            return readJsonAsync(require.resolve('../../package.json')).then(cliPkgConfig => {
                cfg.cliPackageJsonConfig = cliPkgConfig;
            });
        })
        .then(() => {
            return readJsonAsync(require.resolve('../../configs/angular-build.json'))
                .then((angularBuildConfig: AngularBuildConfig) => {
                    cfg.angularBuildConfigMaster = angularBuildConfig;
                });
        })
        .then(() => {
            return readJsonAsync(require.resolve('../../configs/tsconfig.json'))
                .then((tsConfig: any) => {
                    cfg.tsConfigMaster = tsConfig;
                });
        })
        .then(() => {
            return readJsonAsync(require.resolve('../../configs/tsconfig.browser.json'))
                .then((tsConfig: any) => {
                    cfg.tsConfigBrowserMaster = tsConfig;
                });
        })
        .then(() => {
            return readJsonAsync(require.resolve('../../configs/tsconfig.server.json'))
                .then((tsConfig: any) => {
                    cfg.tsConfigServerMaster = tsConfig;
                });
        })
        .then(() => {
            return readJsonAsync(require.resolve('../../configs/tsconfig.test.json'))
                .then((tsConfig: any) => {
                    cfg.tsConfigTestMaster = tsConfig;
                });
        })
        .then(() => {
            return readJsonAsync(require.resolve('../../configs/favicon-config.json'))
                .then((faviconConfig: IconPluginOptions) => {
                    cfg.faviconConfigMaster = faviconConfig;
                });
        })
        // Read user angular-build.json
        .then(() => {
            const cliPath = path.resolve(projectRoot, 'angular-build.json');
            return checkFileOrDirectoryExistsAsync(cliPath).then((exists: boolean) => {
                cfg.angularBuildConfigFileExists = exists;
                if (exists) {
                    return readJsonAsync(cliPath).then((buildConfig: any) => {
                        buildConfig = buildConfig || {};
                        buildConfig.apps = buildConfig.apps || [];
                        cfg.userAngularBuildConfig = buildConfig;
                    });
                } else {
                    return Promise.resolve();
                }
            });
        })
        // Read user angular-cli.json
        .then(() => {
            const cliPath = path.resolve(projectRoot, 'angular-cli.json');
            return checkFileOrDirectoryExistsAsync(cliPath).then((exists: boolean) => {
                cfg.angularCliConfigFileExists = exists;
                if (exists) {
                    return readJsonAsync(cliPath).then((cliConfig: any) => {
                        cliConfig = cliConfig || {};
                        cliConfig.apps = cliConfig.apps || [];
                        cfg.userAngularCliConfig = cliConfig;
                    });
                } else {
                    return Promise.resolve();
                }
            });
        })
        // merge
        .then(() => mergeConfigAsync(cfg))
        // save angular-build.json file
        .then(() => {
            if (cfg.angularBuildConfigFileExists && cfg.commandOptions.overrideAngularBuildConfigFile === false) {
                return Promise.resolve();
            } else {
                if (cfg.angularBuildConfigFileExists && !cfg.commandOptions.overrideAngularBuildConfigFile) {

                    const userAngularBuildConfigClone = Object.assign({}, cfg.userAngularBuildConfig);
                    if ((userAngularBuildConfigClone as any)['$schema']) {
                        delete (userAngularBuildConfigClone as any)['$schema'];
                    }

                    const errors = validateSchema(schema, userAngularBuildConfigClone);
                    if (errors.length === 0) {
                        return Promise.resolve();
                    }
                }

                return new Promise((resolve, reject) => {
                    fs.writeFile(path.resolve(projectRoot, 'angular-build.json'),
                        JSON.stringify(cfg.angularBuildConfigMaster, null, 2),
                        (err: any) => err ? reject(err) : resolve());
                })
                    .then(() => {
                        logger.logLine(`${actionCount++ ? '' : '\n'}` +
                            colorize(`${cfg.angularBuildConfigFileExists ? 'Updated' : 'Created'}:`, 'green') +
                            ' angular-build.json');
                        return;
                    });
            }
        })
        // copy webpack.config file
        .then(() => {
            const webpackConfigFileName = 'webpack.config.js';
            return new Promise((resolve, reject) => {
                fs.copy(require.resolve('../../configs/webpack.config.js'),
                    path.resolve(projectRoot, webpackConfigFileName),
                    (err: any) => {
                        err ? reject(err) : resolve();
                    });
            })
                .then(() => {
                    logger.logLine(`${actionCount++ ? '' : '\n'}` +
                        colorize('Created:', 'green') +
                        ' ' +
                        webpackConfigFileName);
                    return;
                });
        })
        // copy webpack.config.service-worker file
        .then(() => {
            const swWebpackConfigFile = 'webpack.config.service-worker.js';

            return Promise.resolve(true)
                .then((shouldCopy: boolean) => {
                    if (shouldCopy) {
                        return new Promise((resolve, reject) => {
                            fs.copy(require.resolve(`../../configs/${swWebpackConfigFile}`),
                                path.resolve(projectRoot, swWebpackConfigFile),
                                (err: any) => {
                                    err ? reject(err) : resolve();
                                });
                        })
                            .then(() => {
                                logger.logLine(`${actionCount++ ? '' : '\n'}` +
                                    colorize('Created:', 'green') +
                                    ' ' +
                                    swWebpackConfigFile);
                                return;
                            });
                    } else {
                        return Promise.resolve();
                    }
                });
        })
        // copy empty.js
        .then(() => {
            const emptyPath = path.resolve(projectRoot, 'empty.js');
            return checkFileOrDirectoryExistsAsync(emptyPath).then(exists => {
                if (exists) {
                    return Promise.resolve();
                } else {
                    return new Promise((resolve, reject) => {
                        fs.copy(require.resolve('../../configs/empty.js'),
                            emptyPath,
                            (err: any) => {
                                err ? reject(err) : resolve();
                            });
                    })
                        .then(() => {
                            logger.logLine(`${actionCount++ ? '' : '\n'}` + colorize('Created:', 'green') + ' empty.js');
                            return;
                        });
                }
            });
        })
        // copy karma.conf.js
        .then(() => {
            if (!cfg.commandOptions.includeTestConfigs) {
                return Promise.resolve(null);
            }
            const karmaPath = path.resolve(projectRoot, 'karma.conf.js');
            return checkFileOrDirectoryExistsAsync(karmaPath).then(exists => {
                if (exists) {
                    return Promise.resolve();
                } else {
                    return new Promise((resolve, reject) => {
                        fs.copy(require.resolve('../../configs/karma.conf.js'),
                            karmaPath,
                            (err: any) => {
                                err ? reject(err) : resolve();
                            });
                    })
                        .then(() => {
                            logger.logLine(`${actionCount++ ? '' : '\n'}` + colorize('Created:', 'green') + ' karma.conf.js');
                            return;
                        });
                }
            });
        })
        // copy protractor.conf.js
        .then(() => {
            if (!cfg.commandOptions.includeTestConfigs) {
                return Promise.resolve(null);
            }
            const protractorPath = path.resolve(projectRoot, 'protractor.conf.js');
            return checkFileOrDirectoryExistsAsync(protractorPath).then(exists => {
                if (exists) {
                    return Promise.resolve();
                } else {
                    return new Promise((resolve, reject) => {
                        fs.readFile(require.resolve('../../configs/protractor.conf.js'),
                            'utf8',
                            (err: any, data: any) => {
                                err ? reject(err) : resolve(data);
                            });
                    })
                        .then((data: string) => {
                            const appConfig = cfg.angularBuildConfigMaster.apps[0];
                            const appRoot = appConfig.root || 'src';
                            const content = data.replace(`const appRoot = 'src';`, `const appRoot = '${appRoot}';`);
                            return new Promise((resolve, reject) => {
                                fs.writeFile(path.resolve(projectRoot, 'protractor.conf.js'),
                                    content,
                                    (err: any) => {
                                        err ? reject(err) : resolve();
                                    });
                            });
                        })
                        .then(() => {
                            logger.logLine(`${actionCount++ ? '' : '\n'}` +
                                colorize('Created:', 'green') +
                                ' protractor.conf.js');
                            return;
                        });
                }
            });
        })
        // Create src folder
        .then(() => {
            const appConfig = cfg.angularBuildConfigMaster.apps[0];
            const srcPath = path.resolve(projectRoot, appConfig.root);
            return checkFileOrDirectoryExistsAsync(srcPath, true).then((exists: boolean) => {
                if (exists) {
                    return Promise.resolve();
                } else {
                    return new Promise((resolve, reject) => {
                        fs.mkdir(srcPath, (err: any) => err ? reject(err) : resolve());
                    }).then(() => {
                        return;
                    });
                }
            }
            );
        })
        // save tsconfig.json file
        .then(() => {
            const tsConfigPath = path.resolve(projectRoot, 'tsconfig.json');
            return checkFileOrDirectoryExistsAsync(tsConfigPath).then(exists => {
                if (exists) {
                    return Promise.resolve();
                } else {
                    const appConfig = cfg.angularBuildConfigMaster.apps[0];
                    const tsConfig: any = cfg.tsConfigMaster;
                    tsConfig.include = [appConfig.root];
                    tsConfig.exclude = [`./${appConfig.root}/main.*.aot.ts`];

                    // Create
                    return new Promise((resolve, reject) => {
                        fs.writeFile(tsConfigPath,
                            JSON.stringify(tsConfig, null, 2),
                            (err: any) => err ? reject(err) : resolve());
                    })
                        .then(() => {
                            logger.logLine(`${actionCount++ ? '' : '\n'}` +
                                colorize('Created:', 'green') +
                                ' tsconfig.json');
                            return;
                        });
                }
            });
        })
        // save tsconfig.browser.json file
        .then(() => {
            //const appConfig = cfg.angularBuildConfigMaster.apps[0];
            const tsConfigPath = path.resolve(projectRoot, 'tsconfig.browser.json');
            return checkFileOrDirectoryExistsAsync(tsConfigPath).then(exists => {
                if (exists) {
                    return Promise.resolve();
                } else {
                    const appConfig = cfg.angularBuildConfigMaster.apps[0];
                    const tsConfig: any = cfg.tsConfigBrowserMaster;
                    //tsConfig.angularCompilerOptions = {
                    //    entryModule: `./${appConfig.root}/app/app.browser.module#AppBrowserModule`
                    //};
                    tsConfig.exclude = [
                        `./${appConfig.root}/karma-test*.ts`,
                        `./${appConfig.root}/main*.aot.ts`,
                        '**/*.spec.ts',
                        '**/*.e2e.ts'
                    ];

                    // Create
                    return new Promise((resolve, reject) => {
                        fs.writeFile(tsConfigPath,
                            JSON.stringify(tsConfig, null, 2),
                            (err: any) => err ? reject(err) : resolve());
                    })
                        .then(() => {
                            logger.logLine(`${actionCount++ ? '' : '\n'}` +
                                colorize('Created:', 'green') +
                                ' tsconfig.browser.json');
                            return;
                        });
                }
            });
        })
        // save tsconfig.server.json file
        .then(() => {
            //const appConfig = cfg.angularBuildConfigMaster.apps[0];
            const tsConfigPath = path.resolve(projectRoot, 'tsconfig.server.json');
            return checkFileOrDirectoryExistsAsync(tsConfigPath).then(exists => {
                if (exists) {
                    return Promise.resolve();
                } else {
                    const appConfig = cfg.angularBuildConfigMaster.apps[0];
                    const tsConfig: any = cfg.tsConfigServerMaster;
                    tsConfig.angularCompilerOptions = {
                        entryModule: `./${appConfig.root}/app/app.server.module#AppServerModule`
                    };
                    tsConfig.exclude = [
                        `./${appConfig.root}/karma-test*.ts`,
                        `./${appConfig.root}/main*.aot.ts`,
                        '**/*.spec.ts',
                        '**/*.e2e.ts'
                    ];

                    // Create
                    return new Promise((resolve, reject) => {
                        fs.writeFile(tsConfigPath,
                            JSON.stringify(tsConfig, null, 2),
                            (err: any) => err ? reject(err) : resolve());
                    })
                        .then(() => {
                            logger.logLine(`${actionCount++ ? '' : '\n'}` +
                                colorize('Created:', 'green') +
                                ' tsconfig.server.json');
                            return;
                        });
                }
            });
        })
        // save tsconfig.test.json file
        .then(() => {
            if (!cfg.commandOptions.includeTestConfigs) {
                return Promise.resolve(null);
            }

            const tsConfigPath = path.resolve(projectRoot, 'tsconfig.test.json');
            return checkFileOrDirectoryExistsAsync(tsConfigPath).then(exists => {
                if (exists) {
                    return Promise.resolve();
                } else {
                    const appConfig = cfg.angularBuildConfigMaster.apps[0];
                    const tsConfig: any = cfg.tsConfigTestMaster;
                    tsConfig.files = [
                        `./${appConfig.root}/karma-test.browser.ts`
                    ];
                    tsConfig.include = [
                        `./${appConfig.root}/**/*.spec.ts`
                    ];

                    // Create
                    return new Promise((resolve, reject) => {
                        fs.writeFile(tsConfigPath,
                            JSON.stringify(tsConfig, null, 2),
                            (err: any) => err ? reject(err) : resolve());
                    })
                        .then(() => {
                            logger.logLine(`${actionCount++ ? '' : '\n'}` +
                                colorize('Created:', 'green') +
                                ' tsconfig.test.json');
                            return;
                        });
                }
            });
        })
        // save favicon-config.json file
        .then(() => {
            const appConfig = cfg.angularBuildConfigMaster.apps[0];
            const faviconConfigFileName = appConfig.faviconConfig || 'favicon-config.json';
            const faviconConfigPath = path
                .resolve(projectRoot, appConfig.root, faviconConfigFileName);

            let userFaviconConfigExists = false;
            return checkFileOrDirectoryExistsAsync(faviconConfigPath).then(exists => {
                if (exists) {
                    userFaviconConfigExists = true;
                    // Merge
                    return readJsonAsync(faviconConfigPath).then((userFaviconConfig: any) => {
                        const cloneFaviconConfig = Object.assign({}, userFaviconConfig);
                        if ((cloneFaviconConfig as any)['$schema']) {
                            delete (cloneFaviconConfig as any)['$schema'];
                        }


                        //const validate = ajv().compile(faviconSchema);
                        //const valid = validate(cloneFaviconConfig);
                        const errors = validateSchema(faviconSchema, cloneFaviconConfig);
                        if (errors.length) {
                            return Promise.resolve(null);
                        }

                        if (errors.length === 0 && userFaviconConfig.masterPicture) {
                            return Promise.resolve(null);
                        }

                        if (errors.length) {
                            return Promise.resolve(cfg.faviconConfigMaster);

                        }

                        userFaviconConfig.masterPicture = userFaviconConfig.masterPicture ||
                            cfg.faviconConfigMaster.masterPicture;

                        return Object.assign({}, cfg.faviconConfigMaster, userFaviconConfig);

                    });
                } else {
                    return Promise.resolve(cfg.faviconConfigMaster);
                }
            }).then((faviconConfig: any) => {
                if (!faviconConfig) {
                    return Promise.resolve();
                }

                // Create
                return new Promise((resolve, reject) => {
                    fs.writeFile(faviconConfigPath,
                        JSON.stringify(faviconConfig, null, 2),
                        (err: any) => err ? reject(err) : resolve());
                })
                    .then(() => {
                        const relativePath = path.relative(projectRoot, faviconConfigPath);
                        logger.logLine(`${actionCount++ ? '' : '\n'}` +
                            colorize(`${userFaviconConfigExists ? 'Updated' : 'Created'}:`, 'green') +
                            ' ' +
                            relativePath);
                        return;
                    });
            });
        })
        // copy polyfills.ts
        .then(() => {
            const appConfig = cfg.angularBuildConfigMaster.apps[0];
            return checkFileOrDirectoryExistsAsync(path.resolve(projectRoot, appConfig.root, 'polyfills.ts'))
                .then(exists => {
                    if (exists) {
                        return Promise.resolve();
                    } else {
                        return new Promise((resolve, reject) => {
                            fs.copy(require.resolve('../../configs/polyfills.ts'),
                                path.resolve(projectRoot, appConfig.root, 'polyfills.ts'),
                                (err: any) => {
                                    err ? reject(err) : resolve();
                                });
                        })
                            .then(() => {
                                logger.logLine(`${actionCount++ ? '' : '\n'}` +
                                    colorize('Created:', 'green') +
                                    ' ' +
                                    path.join(appConfig.root, 'polyfills.ts'));
                                return;
                            });
                    }
                });

        })
        // copy rxjs.imports.ts
        .then(() => {
            const appConfig = cfg.angularBuildConfigMaster.apps[0];
            return checkFileOrDirectoryExistsAsync(path.resolve(projectRoot, appConfig.root, 'rxjs.imports.ts'))
                .then(exists => {
                    if (exists) {
                        return Promise.resolve();
                    } else {
                        return new Promise((resolve, reject) => {
                            fs.copy(require.resolve('../../configs/rxjs.imports.ts'),
                                path.resolve(projectRoot, appConfig.root, 'rxjs.imports.ts'),
                                (err: any) => {
                                    err ? reject(err) : resolve();
                                });
                        })
                            .then(() => {
                                logger.logLine(`${actionCount++ ? '' : '\n'}` +
                                    colorize('Created:', 'green') +
                                    ' ' +
                                    path.join(appConfig.root, 'rxjs.imports.ts'));
                                return;
                            });
                    }
                });

        })
        // copy typings.d.ts
        .then(() => {
            const appConfig = cfg.angularBuildConfigMaster.apps[0];
            return checkFileOrDirectoryExistsAsync(path.resolve(projectRoot, appConfig.root, 'typings.d.ts'))
                .then(exists => {
                    if (exists) {
                        return Promise.resolve();
                    } else {
                        return new Promise((resolve, reject) => {
                            fs.copy(require.resolve('../../configs/typings.d.ts'),
                                path.resolve(projectRoot, appConfig.root, 'typings.d.ts'),
                                (err: any) => {
                                    err ? reject(err) : resolve();
                                });
                        })
                            .then(() => {
                                logger.logLine(`${actionCount++ ? '' : '\n'}` +
                                    colorize('Created:', 'green') +
                                    ' ' +
                                    path.join(appConfig.root, 'typings.d.ts'));
                                return;
                            });
                    }
                });

        })
        // copy karma-test.browser.ts
        .then(() => {
            if (!cfg.commandOptions.includeTestConfigs) {
                return Promise.resolve(null);
            }
            const appConfig = cfg.angularBuildConfigMaster.apps[0];
            return checkFileOrDirectoryExistsAsync(path.resolve(projectRoot, appConfig.root, 'karma-test.browser.ts'))
                .then(exists => {
                    if (exists) {
                        return Promise.resolve();
                    } else {
                        return new Promise((resolve, reject) => {
                            fs.copy(require.resolve('../../configs/karma-test.browser.ts'),
                                path.resolve(projectRoot, appConfig.root, 'karma-test.browser.ts'),
                                (err: any) => {
                                    err ? reject(err) : resolve();
                                });
                        })
                            .then(() => {
                                logger.logLine(`${actionCount++ ? '' : '\n'}` +
                                    colorize('Created:', 'green') +
                                    ' ' +
                                    path.join(appConfig.root, 'karma-test.browser.ts'));
                                return;
                            });
                    }
                });

        })
        // copy styles.scss
        .then(() => {
            const appConfig = cfg.angularBuildConfigMaster.apps[0];
            return checkFileOrDirectoryExistsAsync(path.resolve(projectRoot, appConfig.root, 'styles.scss'))
                .then(exists => {
                    if (exists) {
                        return Promise.resolve();
                    } else {
                        return new Promise((resolve, reject) => {
                            fs.copy(require.resolve('../../configs/styles.scss'),
                                path.resolve(projectRoot, appConfig.root, 'styles.scss'),
                                (err: any) => {
                                    err ? reject(err) : resolve();
                                });
                        })
                            .then(() => {
                                logger.logLine(`${actionCount++ ? '' : '\n'}` +
                                    colorize('Created:', 'green') +
                                    ' ' +
                                    path.join(appConfig.root, 'styles.scss'));
                                return;
                            });
                    }
                });

        })
        // create environments folder
        .then(() => {
            const appConfig = cfg.angularBuildConfigMaster.apps[0];
            const environmentsPath = path.resolve(projectRoot, appConfig.root, 'environments');
            return checkFileOrDirectoryExistsAsync(environmentsPath, true).then((exists: boolean) => {
                if (exists) {
                    return Promise.resolve();
                } else {
                    return new Promise((resolve, reject) => {
                        fs.mkdir(environmentsPath, (err: any) => err ? reject(err) : resolve());
                    }).then(() => {
                        return;
                    });
                }
            }
            );
        })
        // copy environment files
        .then(() => {
            const appConfig = cfg.angularBuildConfigMaster.apps[0];
            return checkFileOrDirectoryExistsAsync(path
                .resolve(projectRoot, appConfig.root, 'environments', 'environment.ts'))
                .then(exists => {
                    if (exists) {
                        return Promise.resolve();
                    } else {
                        return new Promise((resolve, reject) => {
                            fs.copy(require.resolve('../../configs/environment.ts'),
                                path.resolve(projectRoot, appConfig.root, 'environments', 'environment.ts'),
                                (err: any) => {
                                    err ? reject(err) : resolve();
                                });
                        })
                            .then(() => {
                                logger.logLine(`${actionCount++ ? '' : '\n'}` +
                                    colorize('Created:', 'green') +
                                    ' ' +
                                    path.join(appConfig.root, 'environments', 'environment.ts'));
                                return;
                            });
                    }
                }).then(() => {
                    return checkFileOrDirectoryExistsAsync(path.resolve(projectRoot,
                        appConfig.root,
                        'environments',
                        'environment.prod.ts'))
                        .then(exists => {
                            if (exists) {
                                return Promise.resolve();
                            } else {
                                return new Promise((resolve, reject) => {
                                    fs.copy(require.resolve('../../configs/environment.prod.ts'),
                                        path
                                            .resolve(projectRoot,
                                            appConfig
                                                .root,
                                            'environments',
                                            'environment.prod.ts'),
                                        (err: any) => {
                                            err ? reject(err) : resolve();
                                        });
                                })
                                    .then(() => {
                                        logger.logLine(`${actionCount++ ? '' : '\n'}` +
                                            colorize('Created:', 'green') +
                                            ' ' +
                                            path.join(appConfig.root, 'environments', 'environment.prod.ts'));
                                        return;
                                    });
                            }
                        });
                });
        })
        // update package.json
        // TODO: to review
        .then(() => {
            let outDir = 'dist';
            if (cfg.userAngularBuildConfig &&
                cfg.userAngularBuildConfig.apps &&
                cfg.userAngularBuildConfig.apps.length) {
                const firstAppConfig = cfg.userAngularBuildConfig.apps[0];
                outDir = firstAppConfig.outDir || 'dist';
            }

            const configOpt = ' ';

            let packageScripts: any = {
                "build:dll": `webpack${configOpt}--env.dll --colors --bail`,
                "build:dev": `webpack${configOpt}--env.dev  --profile --colors`,
                "build:dev:universal": `webpack${configOpt}--env.universal --env.dev --profile --colors --bail`,

                "build:prod": `webpack${configOpt}--env.prod --profile --colors --bail`,
                "build:prod:aot": `webpack${configOpt}--env.aot --env.prod --profile --colors --bail`,
                "build:prod:universal": `webpack${configOpt}--env.universal --env.prod --profile --colors --bail`,
                "build:prod:universal:aot": `webpack${configOpt
                }--env.universal --env.aot --env.prod --env.app=browser --profile --colors --bail & webpack${
                configOpt}--env.universal --env.aot --env.prod --env.app=server --colors --bail`,

                // TODO: to review
                "build": `webpack${configOpt} --profile --colors`,
                // TODO: to review
                "build:universal": 'build:prod:universal:aot'

                //"lint": `npm run tslint \"${appConfig.root}/**/*.ts\"`,
            };

            // Clean
            if (cfg.userAngularBuildConfig &&
                cfg.userAngularBuildConfig.apps &&
                cfg.userAngularBuildConfig.apps.length) {
                cfg.userAngularBuildConfig.apps.forEach((appConfig: AppConfig) => {
                    if (appConfig.outDir === 'wwwroot') {
                        packageScripts[`clean:${appConfig.outDir}`] = `rimraf ${appConfig.outDir}/*.js ${appConfig.outDir}/*.css ${appConfig.outDir}/*.json`;
                    } else {
                        packageScripts[`clean:${appConfig.outDir}`] = `rimraf ${appConfig.outDir}`;
                    }
                });
            }

            packageScripts['clean:browser-aot-compiled'] = 'rimraf browser-aot-compiled';
            packageScripts['clean:server-aot-compiled'] = 'rimraf server-aot-compiled';
            packageScripts['clean:coverage'] = 'rimraf coverage';

            // Tests
            // TODO: to review
            //const pkgConfigTest: any = {
            //    "test": 'karma start',

            //    // TODO: to review
            //    "e2e": 'npm-run-all -p -r http-server:run protractor',
            //    "e2e:live": 'npm-run-all -p -r http-server:run protractor -- --elementExplorer',

            //    "pree2e": 'webdriver:update -- --standalone',

            //    // TODO: to review
            //    "webdriver:start": 'webdriver-manager start',
            //    "webdriver:update": 'webdriver-manager update',
            //    "protractor": 'protractor',
            //    "webdriver-manager": 'webdriver-manager',
            //};
            //packageScripts = Object.assign(packageScripts, pkgConfigTest);

            // Http server
            const pkgConfigServer: any = {
                "serve:dev": `webpack-dev-server ${configOpt}--open --progress --inline --hot --watch --port 5000`,
                // TODO: to review
                "serve": 'serve:dev',
                "http-server:run": `http-server ${outDir} -p 5000 -c-1 --cors`
            };
            packageScripts = Object.assign(packageScripts, pkgConfigServer);

            // ASP.Net Core
            if (cfg.isAspNetCore) {
                const pkgConfigAspNet: any = {
                    //"dotnet:run:dev": 'cross-env ASPNETCORE_ENVIRONMENT=Development dotnet run environment=development',
                    "dotnet:run:dev": 'dotnet run environment=development',
                    "dotnet:run:prod":
                    'dotnet run --configuration Release environment=production',
                    "dotnet:run": 'dotnet run'
                };
                packageScripts = Object.assign(packageScripts, pkgConfigAspNet);
            }

            // Http server
            const pkgConfigMap: any = {
                //"cross-env": 'cross-env',
                "rimraf": 'rimraf',
                ////"tslint": 'tslint',
                "webpack": 'webpack',
                "webpack-dev-server": 'webpack-dev-server'
            };
            packageScripts = Object.assign(packageScripts, pkgConfigMap);

            // read package json
            return readJsonAsync(cfg.userPackageConfigFile).then((userPackageConfig: any) => {
                cfg.userPackageConfig = userPackageConfig;

                let shouldUpdate = true;
                if (cfg.userPackageConfig.scripts) {
                    const foundLen = Object.keys(packageScripts)
                        .filter((key: string) => cfg.userPackageConfig.scripts[key] &&
                            cfg.userPackageConfig.scripts[key] === packageScripts[key]).length;
                    if (foundLen === Object.keys(packageScripts).length) {
                        shouldUpdate = false;
                    }
                }
                if (shouldUpdate) {
                    cfg.userPackageConfig.scripts = Object
                        .assign({}, cfg.userPackageConfig.scripts || {}, packageScripts);
                    return new Promise((resolve, reject) => {
                        fs.writeFile(cfg.userPackageConfigFile,
                            JSON.stringify(cfg.userPackageConfig, null, 2),
                            (err: any) => err ? reject(err) : resolve());
                    })
                        .then(() => {
                            logger.logLine(colorize('Updated:', 'green') + ' package.json');
                            return;
                        });
                } else {
                    return Promise.resolve();
                }
            });
        })
        .then(() => {
            return checkAndInstallToolings(cfg).then(() => {
                if (cfg.commandOptions.link && !cfg.cliIsLocal) {
                    if (cfg.commandOptions.packageManager === 'yarn') {
                        // TODO: to review stdio with ui.stdOut
                        return spawnAsync('yarn',
                            ['link', '@bizappframework/angular-build']).then(() => {
                                logger.logLine('\n' + colorize('Linked:', 'green') + ' @bizappframework/angular-build');
                                return 0;
                            });
                    } else {
                        // TODO: to review stdio with ui.stdOut
                        return spawnAsync('npm',
                            ['link', '@bizappframework/angular-build', '--color', 'always', '--loglevel', 'error']).then(
                            () => {
                                logger.logLine('\n' + colorize('Linked:', 'green') + ' @bizappframework/angular-build');
                                return 0;
                            });
                    }

                } else {
                    return Promise.resolve(0);
                }
            });
        })
        .then(() => {
            logger.logLine('Done.');
            return 0;
        });
}

// Private functions
function mergeConfigAsync(cfg: InitConfig): Promise<void> {
    return mergeConfigWithPossibleAsync(cfg)
        .then(() => mergeConfigWithAngularCli(cfg))
        .then(() => mergeConfigWithUserAngularBuildConfig(cfg))
        .then(() => mergeConfigWithUserFaviconConfig(cfg))
        .then(() => mergeWithCommandOptions(cfg));
    //.then(() => (cfg.commandOptions.prompt)
    //    ? mergeConfigWithPromptAsync(cfg)
    //    : Promise.resolve());
}

function mergeConfigWithPossibleAsync(cfg: InitConfig): Promise<void> {
    const projectRoot = cfg.cwd;
    const appConfig = cfg.angularBuildConfigMaster.apps[0];

    const possibleSrcDirs = ['Client', 'src'];
    const possibleOutDirs = ['wwwroot', 'dist'];
    const possibleMains = ['main.browser.ts', 'main.ts'];
    const possibleStyles = ['styles.scss', 'styles.sass', 'styles.less', 'styles.stylus', 'styles.css'];
    const possibleFavicons = ['logo.svg', 'logo.png', 'favlogo.svg', 'favlogo.png', 'favicon.svg', 'favicon.png'];

    // root
    return findFileOrDirectoryFromPossibleAsync(projectRoot, possibleSrcDirs, appConfig.root, true)
        .then((foundRoot: string) => {
            appConfig.root = foundRoot || appConfig.root;

            // outDir
            return findFileOrDirectoryFromPossibleAsync(projectRoot, possibleOutDirs, appConfig.outDir, true)
                .then((foundOutDir: string) => {
                    appConfig.outDir = foundOutDir || appConfig.outDir;
                    return;
                });
        })
        .then(() => {
            // main
            return findFileOrDirectoryFromPossibleAsync(path.resolve(projectRoot, appConfig.root),
                possibleMains,
                appConfig.main,
                false)
                .then((foundMain: string) => {
                    appConfig.main = foundMain || appConfig.main;
                    return;
                });
        })
        .then(() => {
            // styles
            return findFileOrDirectoryFromPossibleAsync(path.resolve(projectRoot, appConfig.root),
                possibleStyles,
                'styles.scss',
                false)
                .then((foundStyle: string) => {
                    if (foundStyle) {
                        if (Array.isArray(appConfig.styles)) {
                            if (appConfig.styles.indexOf(foundStyle) === -1) {
                                appConfig.styles.push(foundStyle);
                            }
                        } else {
                            if (!appConfig.styles) {
                                appConfig.styles = [foundStyle];
                            }
                        }
                    }

                    return;
                });
        })
        .then(() => {
            // asset folder
            return findFileOrDirectoryFromPossibleAsync(path.resolve(projectRoot, appConfig.root),
                ['assets'],
                'asset',
                true)
                .then((foundAsset: string) => {
                    if (foundAsset) {
                        if (Array.isArray(appConfig.assets)) {
                            if (appConfig.assets.indexOf(foundAsset) === -1 &&
                                appConfig.assets.indexOf('assets/**/*') === -1) {
                                appConfig.assets.push('assets/**/*');
                            }
                        } else {
                            if (!appConfig.styles) {
                                appConfig.assets = ['assets/**/*'];
                            }
                        }
                    }

                    return;
                });
        })
        .then(() => {
            // robots.txt
            return findFileOrDirectoryFromPossibleAsync(path.resolve(projectRoot, appConfig.root),
                ['robots.txt'],
                'robots.txt',
                false)
                .then((foundAsset: string) => {
                    if (foundAsset) {
                        if (Array.isArray(appConfig.assets)) {
                            if (appConfig.assets.indexOf(foundAsset) === -1) {
                                appConfig.assets.push(foundAsset);
                            }
                        } else {
                            if (!appConfig.styles) {
                                appConfig.assets = [foundAsset];
                            }
                        }
                    }

                    return;
                });
        })
        .then(() => {
            // humans.txt
            return findFileOrDirectoryFromPossibleAsync(path.resolve(projectRoot, appConfig.root),
                ['humans.txt'],
                'humans.txt',
                false)
                .then((foundAsset: string) => {
                    if (foundAsset) {
                        if (Array.isArray(appConfig.assets)) {
                            if (appConfig.assets.indexOf(foundAsset) === -1) {
                                appConfig.assets.push(foundAsset);
                            }
                        } else {
                            if (!appConfig.styles) {
                                appConfig.assets = [foundAsset];
                            }
                        }
                    }

                    return;
                });
        })
        .then(() => {
            // favicon
            return findFileOrDirectoryFromPossibleAsync(path.resolve(projectRoot, appConfig.root),
                possibleFavicons,
                'favicon.svg',
                false)
                .then((foundFavicon: string) => {
                    if (foundFavicon) {
                        cfg.faviconConfigMaster.masterPicture = foundFavicon;
                        appConfig.faviconConfig = appConfig.faviconConfig || 'favicon-config.json';
                    } else {
                        if (cfg.faviconConfigMaster) {
                            cfg.faviconConfigMaster.masterPicture = '';
                        }
                    }

                    return;
                });
        })
        .then(() => {
            // index
            return findFileOrDirectoryFromPossibleAsync(path.resolve(projectRoot, appConfig.root),
                ['index.html'],
                'index.html',
                false)
                .then((foundIndex: string) => {
                    if (foundIndex) {
                        appConfig.index = foundIndex;
                    }

                    return;
                });
        })
        .then(() => {
            // asp.net core
            return checkFileOrDirectoryExistsAsync(path.resolve(projectRoot, 'Views', 'Shared'), true)
                .then(exists => exists
                    ? checkFileOrDirectoryExistsAsync(path.resolve(projectRoot, 'wwwroot'), true)
                    : Promise.resolve(false));
        })
        .then(aspNet => {
            if (aspNet) {
                if (appConfig.index) {
                    appConfig.index = '';
                }
                cfg.isAspNetCore = true;
                appConfig.htmlInjectOptions = appConfig.htmlInjectOptions || {};
                appConfig.htmlInjectOptions.scriptsOutFileName = '../Views/Shared/_ScriptsPartial.cshtml';
                appConfig.htmlInjectOptions.iconsOutFileName = '../Views/Shared/_FavIconsPartial.cshtml';
                appConfig.htmlInjectOptions.stylesOutFileName = '../Views/Shared/_StylesPartial.cshtml';
                appConfig.htmlInjectOptions
                    .customTagAttributes = [
                        { tagName: 'link', attribute: { "asp-append-version": true } },
                        { tagName: 'script', attribute: { "asp-append-version": true } }
                    ];

            }
            return;
        });
}

function mergeConfigWithAngularCli(cfg: InitConfig): void {
    if (cfg.angularBuildConfigFileExists ||
        !cfg.angularCliConfigFileExists ||
        !cfg.userAngularCliConfig ||
        !cfg.userAngularCliConfig.apps ||
        !cfg.userAngularCliConfig.apps[0]) {
        return;
    }

    const appConfig = cfg.angularBuildConfigMaster.apps[0] as any;
    const cliAppConfig = cfg.userAngularCliConfig.apps[0] as any;
    const appConfigSchema: any = schema.definitions.AppConfig.properties;

    Object.keys(cliAppConfig)
        .filter((key: string) => key === 'deployUrl' || (cfg.userAngularCliConfig[key] !== null && appConfigSchema[key] && key !== 'tsconfig'))
        .forEach((key: string) => {
            if (key === 'deployUrl') {
                appConfig['publicPath'] = cliAppConfig[key];
            } else {
                appConfig[key] = cliAppConfig[key];
            }
        });
}

function mergeConfigWithUserAngularBuildConfig(cfg: InitConfig): void {
    if (!cfg.angularBuildConfigFileExists ||
        !cfg.userAngularBuildConfig ||
        !cfg.userAngularBuildConfig.apps ||
        !cfg.userAngularBuildConfig.apps[0]) {
        return;
    }

    const masterAppConfig = cfg.angularBuildConfigMaster.apps[0] as any;
    const userAppConfig = cfg.userAngularBuildConfig.apps[0] as any;
    const appConfigSchema: any = schema.definitions.AppConfig.properties;

    Object.keys(userAppConfig)
        .filter((key: string) => appConfigSchema[key] && userAppConfig[key] !== null && userAppConfig[key] !== '')
        .forEach((key: string) => {
            masterAppConfig[key] = userAppConfig[key];
        });

}

function mergeConfigWithUserFaviconConfig(cfg: InitConfig): Promise<void> {
    const projectRoot = cfg.cwd;
    let faviconConfigPath = '';
    if (cfg.angularBuildConfigFileExists &&
        cfg.userAngularBuildConfig &&
        cfg.userAngularBuildConfig.apps &&
        cfg.userAngularBuildConfig.apps[0].faviconConfig &&
        cfg.userAngularBuildConfig.apps[0].root) {
        faviconConfigPath = path.resolve(projectRoot,
            cfg.userAngularBuildConfig.apps[0].root,
            cfg.userAngularBuildConfig.apps[0].faviconConfig);
    }

    if (!faviconConfigPath) {
        return Promise.resolve();
    }

    return checkFileOrDirectoryExistsAsync(faviconConfigPath).then((exists: boolean) => {
        cfg.faviconConfigFileExists = exists;
        if (exists) {
            return readJsonAsync(faviconConfigPath).then((faviconConfig: any) => {
                cfg.userFaviconConfig = faviconConfig;
                if (faviconConfig.masterPicture) {
                    cfg.faviconConfigMaster.masterPicture = faviconConfig.masterPicture;
                    cfg.faviconConfigMaster = Object.assign({}, cfg.faviconConfigMaster, faviconConfig);
                }
                return;
            });
        } else {
            return Promise.resolve();
        }
    }).then(() => {
        return;
    });
}

function mergeWithCommandOptions(cfg: InitConfig): void {
    const appConfig = cfg.angularBuildConfigMaster.apps[0];
    const appConfigSchema: any = schema.definitions.AppConfig.properties;

    Object.keys(cfg.commandOptions).forEach((key: string) => {
        const commandOptions: any = cfg.commandOptions;
        if (typeof commandOptions[key] !== 'undefined' &&
            commandOptions[key] !== null &&
            (!Array.isArray(commandOptions[key]) ||
                (Array.isArray(commandOptions[key]) && commandOptions[key].find((s: any) => s !== null))) &&
            key !== 'extends' &&
            appConfigSchema[key]) {
            const obj = appConfig as any;
            if (appConfigSchema[key].type === 'boolean') {
                obj[key] = commandOptions[key].toString().toLowerCase() === 'true';
            } else {
                obj[key] = commandOptions[key];
            }
        }
    });
}

//function mergeConfigWithPromptAsync(cfg: InitConfig): Promise<void> {
//    const appConfig = cfg.angularBuildConfigMaster.apps[0];
//    let askCount = 0;
//    return Promise.resolve(cfg.angularBuildConfigFileExists)
//        .then((exists: boolean) => {

//            if (exists) {
//                if (cfg.commandOptions.overrideAngularBuildConfigFile) {
//                    return Promise.resolve();
//                }
//                return askAsync(`${askCount++ ? '' : '\n'}` + chalk.bgYellow('WARNING:') +
//                    ` Override 'angular-build.json' yes/no (no)?: `)
//                    .then((answer: string) => {
//                        if (answer &&
//                            answer.trim() &&
//                            (answer.trim().toLowerCase() === 'yes' ||
//                                answer.trim().toLowerCase() === 'y')) {
//                            cfg.commandOptions.overrideAngularBuildConfigFile = true;
//                        }
//                    });
//            } else {
//                return Promise.resolve();
//            }
//        })
//        .then(() => {
//            if (cfg.webpackConfigFileExists) {
//                return askAsync(`${askCount++ ? '' : '\n'}` + chalk.bgYellow('WARNING:') +
//                    ` Override '${cfg.commandOptions.webpackConfigFileName}' yes/no (yes)?: `)
//                    .then((answer: string) => {
//                        if (answer &&
//                            answer.trim() &&
//                            (answer.trim().toLowerCase() === 'no' ||
//                                answer.trim().toLowerCase() === 'n')) {
//                            cfg.commandOptions.overrideWebpackConfigFile = false;
//                        } else {
//                            cfg.commandOptions.overrideWebpackConfigFile = true;
//                        }
//                    });
//            } else {
//                return Promise.resolve();
//            }
//        })
//        .then(() => {
//            if (cfg.commandOptions.root ||
//                (cfg.angularBuildConfigFileExists && !cfg.commandOptions.overrideAngularBuildConfigFile)) {
//                return Promise.resolve();
//            }
//            return askAsync(`${askCount++ ? '' : '\n'}` + `Enter client app root folder ${appConfig.root ? `(${appConfig.root})` : ''}: `)
//                .then((answer: string) => {
//                    if (answer && answer.trim()) {
//                        appConfig.root = answer.trim();
//                    }
//                });
//        })
//        .then(() => {
//            if (cfg.commandOptions.outDir ||
//                (cfg.angularBuildConfigFileExists && !cfg.commandOptions.overrideAngularBuildConfigFile)) {
//                return Promise.resolve();
//            }
//            return askAsync(`${askCount++ ? '' : '\n'}` + `Enter build output folder ${appConfig.outDir ? `(${appConfig.outDir})` : ''}: `)
//                .then((answer: string) => {
//                    if (answer && answer.trim()) {
//                        appConfig.outDir = answer.trim();
//                    }
//                });
//        })
//        .then(() => {
//            if (cfg.commandOptions.publicPath ||
//                (cfg.angularBuildConfigFileExists && !cfg.commandOptions.overrideAngularBuildConfigFile)) {
//                return Promise.resolve();
//            }
//            return askAsync(`${askCount++ ? '' : '\n'}` + `Enter public path ${appConfig.publicPath ? `(${appConfig.publicPath})` : ''}: `)
//                .then((answer: string) => {
//                    if (answer && answer.trim()) {
//                        appConfig.publicPath = answer.trim();
//                        if (!appConfig.publicPath.endsWith('/')) {
//                            appConfig.publicPath += '/';
//                        }
//                    }
//                });
//        })
//        .then(() => {
//            if (cfg.commandOptions.main ||
//                (cfg.angularBuildConfigFileExists && !cfg.commandOptions.overrideAngularBuildConfigFile)) {
//                return Promise.resolve();
//            }
//            return askAsync(`${askCount++ ? '' : '\n'}` + `Enter app bootstrap main file ${appConfig.main ? `(${appConfig.main})` : ''}: `)
//                .then((answer: string) => {
//                    if (answer && answer.trim()) {
//                        appConfig.main = answer.trim();
//                    }
//                });
//        })
//        .then(() => {
//            if (cfg.commandOptions.packageManager === 'npm' || cfg.commandOptions.packageManager === 'yarn') {
//                return Promise.resolve();
//            }
//            return askAsync(`${askCount++ ? '' : '\n'}` + `Enter package manager to use - npm/yarn ${cfg.commandOptions.packageManager ? `(${cfg.commandOptions.packageManager})` : '(npm)'}: `)
//                .then((answer: string) => {
//                    if (answer && answer.trim()) {
//                        cfg.commandOptions.packageManager = answer.trim() === 'yarn' ? 'yarn' : 'npm';
//                    }
//                });
//        })
//        .then(() => { return; });
//}

// TODO: to revieow
function checkAndInstallToolings(cfg: InitConfig): Promise<void> {
    const projectRoot = cfg.cwd;
    const ui = cfg.logger;

    const preReleasedPackageNames: string[] = [
    ];

    // TODO: to revieow
    const peerDeps = [
        // warning jshashes@1.0.6: The engine "browser" appears to be invalid.
        '@angular/service-worker',

        // Optional
        //'@angularclass/hmr',

        '@types/node',

        'core-js',
        //'codelyzer',
        //'cross-env',

        'event-source-polyfill',

        //'http-server',

        'ie-shim',
        'intl',

        // TODO: to review
        //'npm-run-all',

        'rimraf',
        'typescript',

        'ts-node',
        'tslib',
        //'tslint',

        'web-animations-js',

        'webpack',
        'webpack-dev-server',
        'webpack-hot-middleware'
    ];

    const peerTestDeps = [
        '@types/jasmine',

        'jasmine-core',
        'jasmine-spec-reporter',

        'karma',
        'karma-chrome-launcher',
        //'karma-cli',
        'karma-coverage-istanbul-reporter',
        'karma-jasmine',
        'karma-jasmine-html-reporter',
        'karma-mocha-reporter',
        //'karma-phantomjs-launcher',
        //'karma-source-map-support',
        'karma-sourcemap-loader',
        'karma-webpack',

        'protractor',

    ];

    const aspWebpackTools = [
        //'reflect-metadata',
        //'isomorphic-fetch',
        //'preboot',
        'aspnet-webpack',
        'aspnet-prerendering',
        '@nguniversal/aspnetcore-engine'
    ];

    const loaderPeerDeps = [
        '@angular/compiler-cli',
        '@angular/compiler',
        '@angular/core',
        '@ngtools/webpack',
        'less',
        'node-sass',
        'stylus'
    ];

    const angularMinimalDeps = [
        '@angular/common',
        '@angular/forms',
        '@angular/http',
        '@angular/router',
        '@angular/platform-browser',
        '@angular/platform-browser-dynamic',
        '@angular/platform-server',

        'rxjs',
        'zone.js'
    ];

    const depSaveFilteredList = [
        '@angular/compiler',
        '@angular/core',
        '@angular/common',
        '@angular/forms',
        '@angular/http',
        '@angular/router',
        '@angular/platform-browser',
        '@angular/platform-browser-dynamic',
        '@angular/platform-server',

        '@angular/service-worker',

        '@angularclass/hmr',

        'aspnet-prerendering',

        'core-js',

        'es6-promise',
        'es6-shim',
        'event-source-polyfill',

        'ie-shim',
        'intl',

        'preboot',

        'reflect-metadata',
        'rxjs',

        'systemjs',

        'ts-helpers',
        'tslib',

        'web-animations-js',
        'zone.js'
    ];

    if (cfg.commandOptions.includeTestConfigs) {
        peerDeps.push(...peerTestDeps);
    }

    const depsToInstall: string[] = [];

    const depPackages: PackageToCheck[] = Object.keys(cfg.cliPackageJsonConfig.dependencies)
        .filter((key: string) => key.match(/loader$/))
        .map((key: string) => {
            const ver = cfg.cliPackageJsonConfig.dependencies[key];
            const isPreReleased = !(preReleasedPackageNames.indexOf(key) === -1);
            return {
                packageName: key,
                version: ver,
                isPreReleased: isPreReleased
            };
        });


    return checkPackagesToInstall(peerDeps, projectRoot)
        .then((packageNames: string[]) => {
            packageNames.forEach((pkgName: string) => {
                if (depsToInstall.indexOf(pkgName) === -1) {
                    depsToInstall.push(pkgName);
                }
            });
        })
        .then(() => {
            if (!cfg.isAspNetCore) {
                return Promise.resolve();
            }

            return checkPackagesToInstall(aspWebpackTools, projectRoot)
                .then((packageNames: string[]) => {
                    packageNames.forEach((pkgName: string) => {
                        if (depsToInstall.indexOf(pkgName) === -1) {
                            depsToInstall.push(pkgName);
                        }
                    });
                });
        })
        .then(() => {
            if (cfg.cliIsLocal) {
                return Promise.resolve();
            }

            return checkPackagesToInstall(depPackages, projectRoot)
                .then((packageNames: string[]) => {
                    packageNames.forEach((pkgName: string) => {
                        if (depsToInstall.indexOf(pkgName) === -1) {
                            depsToInstall.push(pkgName);
                        }
                    });
                });
        })
        .then(() => {
            // TODO: to review
            if (cfg.cliIsLocal) {
                return Promise.resolve();
            }

            return checkPackagesToInstall(loaderPeerDeps, projectRoot)
                .then((packageNames: string[]) => {
                    packageNames.forEach((pkgName: string) => {
                        if (depsToInstall.indexOf(pkgName) === -1) {
                            depsToInstall.push(pkgName);
                        }
                    });
                });
        })
        .then(() => {
            if (depsToInstall.indexOf('@angular/core') > -1) {
                depsToInstall.push(...angularMinimalDeps);
            }

            if (!depsToInstall.length) {
                return Promise.resolve();
            }

            ui.log('\n');
            ui.logLine(`Installing dependencies via ${cfg.commandOptions.packageManager || 'npm'}...`);
            const installedPackages: string[] = [];
            const depsToSave: string[] = [];
            const devDepsToSave: string[] = [];
            depsToInstall.forEach(p => {
                if (depSaveFilteredList.indexOf(p) > -1) {
                    depsToSave.push(p);
                } else {
                    devDepsToSave.push(p);
                }
            });

            return Promise.resolve(0)
                .then(() => {

                    if (!depsToSave.length) {
                        return Promise.resolve();
                    }

                    if (cfg.commandOptions.packageManager === 'yarn') {
                        return spawnAsync('yarn',
                            ['add']
                                .concat(depsToSave))
                            .then(() => {
                                installedPackages.push(...depsToSave);
                                return;
                            });
                    } else {
                        return spawnAsync('npm',
                            ['install', '-S', '--color', 'always', '--loglevel', 'error']
                                .concat(depsToSave))
                            .then(() => {
                                installedPackages.push(...depsToSave);
                                return;
                            });
                    }

                })
                .then(() => {
                    if (!devDepsToSave.length) {
                        return Promise.resolve();
                    }
                    if (cfg.commandOptions.packageManager === 'yarn') {
                        return spawnAsync('yarn',
                            ['add', '-D']
                                .concat(devDepsToSave))
                            .then(() => {
                                installedPackages.push(...devDepsToSave);
                                return;
                            });
                    } else {
                        return spawnAsync('npm',
                            ['install', '-D', '--color', 'always', '--loglevel', 'error']
                                .concat(devDepsToSave))
                            .then(() => {
                                installedPackages.push(...devDepsToSave);
                                return;
                            });
                    }
                })
                .then(() => {
                    if (installedPackages.length) {
                        ui.logLine(colorize(installedPackages.join('\n'), 'green'));
                        ui.logLine('Dependencies were installed.');
                    }
                    return;
                });
        });
}

function checkPackagesToInstall(packagesToCheck: (PackageToCheck | string)[], projectRoot: string): Promise<string[]> {
    const baseDir = path.resolve(projectRoot, 'node_modules');

    const tasks =
        packagesToCheck.map((pkgToCheck: PackageToCheck | string) => typeof pkgToCheck === 'string'
            ? { packageName: pkgToCheck }
            : pkgToCheck)
            .map((packageToCheckObj: PackageToCheck) => {
                return new Promise(res => {
                    resolve(packageToCheckObj.packageName,
                        { basedir: baseDir },
                        (error, resolvedPath) => {
                            if (error) {
                                res(packageToCheckObj);
                            } else {
                                packageToCheckObj.resolvedPath = resolvedPath;
                                res(packageToCheckObj);
                            }
                        });
                }).then((packageObj: any) => {
                    if (packageObj.resolvedPath) {
                        if (packageObj.version) {
                            const versionRange = semver.validRange(packageObj.version);
                            return getVersionfromPackageJsonAsync(path
                                .resolve(projectRoot, 'node_modules', packageObj.packageName))
                                .then((localVer: any) => {
                                    if (localVer && semver.satisfies(localVer, versionRange)) {
                                        return null;
                                    }
                                    if (packageObj.isPreReleased) {
                                        return packageObj.packageName + '@' + packageObj.version;
                                    } else {
                                        return packageObj.packageName;
                                    }
                                });
                        } else {
                            return Promise.resolve(null);
                        }
                    } else {
                        if (packageObj.packageName.match(/^@types\//)) {
                            return checkFileOrDirectoryExistsAsync(path
                                .resolve(projectRoot, 'node_modules', packageObj.packageName),
                                true)
                                .then((exists: boolean) => {
                                    return exists ? null : packageObj.packageName;
                                });
                        }
                        if (packageObj.isPreReleased && packageObj.version) {
                            return Promise.resolve(packageObj.packageName + '@' + packageObj.version);
                        } else {
                            return Promise.resolve(packageObj.packageName);
                        }
                    }
                });
            });

    return Promise.all(tasks)
        .then(packages => {
            return packages.filter(p => !!p);
        });
}
